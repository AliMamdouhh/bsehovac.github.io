<!DOCTYPE html><html><head><style type="text/css">
  body, html, div { margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden; }
  canvas { display: block; }
</style></head><body><div></div>
<script type="text/javascript" src="src/js/components/Draggable.js"></script>
<script type="text/javascript" src="assets/js/three.js"></script>
<script type="text/javascript">

const scene = new THREE.Scene();

const renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );

const container = document.querySelector('div');
container.appendChild( renderer.domElement );

const camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
camera.position.set( 3, 3, 3 );
camera.lookAt( scene.position );

const ambient = new THREE.AmbientLight( 0xffffff, 1.6 );
const directional = new THREE.DirectionalLight( 0xffffff, 0.2 );
directional.position.set( 0.3, 1,  0.6 );

const cube = new THREE.Mesh(
  new THREE.BoxGeometry( 1, 1, 1 ),
  new THREE.MeshStandardMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } )
);

cube.geometry.faces[ 0 ].color.setHex( 0xffaaaa );
cube.geometry.faces[ 1 ].color.setHex( 0xffaaaa );
cube.geometry.faces[ 2 ].color.setHex( 0xaaffaa );
cube.geometry.faces[ 3 ].color.setHex( 0xaaffaa );
cube.geometry.faces[ 4 ].color.setHex( 0xaaaaff );
cube.geometry.faces[ 5 ].color.setHex( 0xaaaaff );
cube.geometry.faces[ 6 ].color.setHex( 0xffffaa );
cube.geometry.faces[ 7 ].color.setHex( 0xffffaa );
cube.geometry.faces[ 8 ].color.setHex( 0xaaffff );
cube.geometry.faces[ 9 ].color.setHex( 0xaaffff );
cube.geometry.faces[ 10 ].color.setHex( 0xffaaff );
cube.geometry.faces[ 11 ].color.setHex( 0xffaaff );

scene.add( camera );
scene.add( cube );
scene.add( ambient );
scene.add( directional );

const animate = () => {
  renderer.render( scene, camera );
  requestAnimationFrame( animate );
}
animate();

const draggable = new Draggable( { vector: THREE.Vector2, invertY: true } );
const drag = {};

draggable.onStart = ( event, position ) => {
  drag.started = false;
  drag.active = true;
};

draggable.onDrag = ( event, position ) => {
  if ( !drag.active ) return;
  if ( !drag.started && position.deltaTotal.length() > 20 ) {

    drag.objectAxis = [ 'y', 'x', 'y', 'x', 'y' ][ Math.round( position.deltaTotal.angle() / ( Math.PI / 2 ) ) ];
    drag.mouseAxis = { y: 'x', x: 'y' }[ drag.objectAxis ];

    if ( drag.objectAxis === 'x' && position.start.x > renderer.getSize().width / 2 ) drag.objectAxis = 'z';

    drag.deltaAngle = 0;
    drag.started = true;

  } else if ( drag.started ) {

    const axis = new THREE.Vector3();
    axis[ drag.objectAxis ] = 1;

    const angle = position.deltaCurrent[ drag.mouseAxis ] / 100 * ( ( drag.objectAxis == 'z' ) ? - 1 : 1 );

    cube.rotateOnWorldAxis( axis, angle );

    drag.deltaAngle += angle;

    if ( Math.abs( drag.deltaAngle ) > Math.PI / 2 ) draggable.onEnd();

  }
};

draggable.onEnd = ( event, position ) => {
  if ( !drag.active ) return;
  cube.rotation.setFromVector3( roundVectorAngle( cube.rotation.toVector3(), false ) );
  drag.active = false;
};

draggable.init( container );

// HELPERS

function roundAngle( angle, minimum ) {
  const round = Math.PI / 2;
  if ( angle == 0 ) return 0;
  if ( minimum !== false ) {
    if ( Math.abs( angle ) < round * minimum ) return 0;
    if ( Math.abs( angle ) < round ) return Math.sign( angle ) * round;
  }
  return Math.round( angle / round ) * round;
}

function roundVectorAngle( angle, minimum ) {
  angle.set(
    roundAngle( angle.x, minimum ),
    roundAngle( angle.y, minimum ),
    roundAngle( angle.z, minimum )
  );
  return angle;
}

</script></body></html>