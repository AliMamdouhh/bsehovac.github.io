<!DOCTYPE html><html><head><style type="text/css">
  body, html, div, canvas { margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden; display: block; }
</style></head><body>
<script type="text/javascript" src="assets/js/three.js"></script>
<script type="text/javascript">

function Controls() {

  const draggable = new Draggable( container );
  const drag = {};

  draggable.onDragStart = position => {

    const intersect = getIntersect( position, cube );
    if ( intersect === false ) return;

    drag.started = false;
    drag.active = true;

    const face = intersect.face.normal;

    attach( helper, scene, cube )

    helper.position.copy( face.clone().multiplyScalar( 0.5 ) );
    helper.rotation.set( face.y * Math.PI / 2, face.x * Math.PI / 2, face.z * Math.PI / 2 );

    helper.updateMatrixWorld();

    drag.start = getIntersect( position, helper ).point;
    drag.total = new THREE.Vector3();
    drag.face = getLargesAxis( face );

    detach( helper, cube, scene );

  };

  draggable.onDragMove = position => {

    if ( !drag.active ) return;

    const intersect = getIntersect( position, helper );
    if ( intersect === false ) return;

    const delta = intersect.point.clone().sub( drag.start );
    drag.total.add( delta );
    drag.start = intersect.point;

    if ( !drag.started && drag.total.length() > 0.1 ) {

      drag.direction = getLargesAxis( drag.total );
      drag.started = true;

      drag.axis = new THREE.Vector3();

      if ( drag.face == 'y' && drag.direction == 'z' ) drag.axis.x = 1;
      if ( drag.face == 'z' && drag.direction == 'y' ) drag.axis.x = -1;
      if ( drag.face == 'z' && drag.direction == 'x' ) drag.axis.y = 1;
      if ( drag.face == 'x' && drag.direction == 'z' ) drag.axis.y = -1;
      if ( drag.face == 'x' && drag.direction == 'y' ) drag.axis.z = 1;
      if ( drag.face == 'y' && drag.direction == 'x' ) drag.axis.z = -1;

    } else if ( drag.started ) {

      object.rotateOnWorldAxis( drag.axis, delta[ drag.direction ] );

    }

  };

  draggable.onDragEnd = position => {

    if ( !drag.active ) return;
    drag.active = false;

  };

  function getIntersect( position, object ) {

    raycaster.setFromCamera( draggable.convertPosition( position.clone() ), camera );
    const intersect = raycaster.intersectObject( object )[ 0 ];
    return ( typeof intersect === 'undefined' ) ? false : intersect;

  }

  function getLargesAxis( vector ) {

    return Object.keys( vector ).reduce( ( a, b ) => Math.abs( vector[ a ] ) > Math.abs( vector[ b ] ) ? a : b );

  }

  function detach( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  }

  function attach( child, scene, parent ) {

    child.applyMatrix( new THREE.Matrix4().getInverse( parent.matrixWorld ) );
    scene.remove( child );
    parent.add( child );

  }

}

function Init() {

  const scene = new THREE.Scene();

  const renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );

  const container = document.createElement('div');
  container.appendChild( renderer.domElement );
  document.body.appendChild( container );

  const camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
  camera.position.set( 3, 3, 3 );
  camera.lookAt( scene.position );

  const ambient = new THREE.AmbientLight( 0xffffff, 1.6 );
  const directional = new THREE.DirectionalLight( 0xffffff, 0.2 );
  directional.position.set( 0.3, 1,  0.6 );

  const raycaster = new THREE.Raycaster();

  const object = new THREE.Object3D();

  const cube = new THREE.Mesh(
    new THREE.BoxGeometry( 1, 1, 1 ),
    new THREE.MeshStandardMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } )
  );

  const helper = new THREE.Mesh(
    new THREE.PlaneGeometry( 2, 2 ),
    new THREE.MeshBasicMaterial( { side: THREE.DoubleSide, transparent: true, opacity: 0.2, color: 0x0033ff } )
  );

  object.add( cube );
  scene.add( helper, camera, object, ambient, directional );

  const animate = () => {

    renderer.render( scene, camera );
    requestAnimationFrame( animate );

  }

  animate();

  window.scene = scene;
  window.cube = cube;
  window.helper = helper;
  window.object = object;
  window.container = container;
  window.raycaster = raycaster;
  window.camera = camera;

}

class Draggable {

  constructor( element ) {

    window.addEventListener( 'touchmove', function () {} );
    document.addEventListener( 'touchmove', function( event ){ event.preventDefault(); }, { passive: false } );

    this.touch = null;

    this.drag = {

      start: ( event ) => {

        if ( event.type == 'mousedown' && event.which != 1 ) return;
        if ( event.type == 'touchstart' && event.touches.length > 1 ) return;
        this.touch = ( event.type == 'touchstart' );
        this.onDragStart( this.getPosition( event ) );
        window.addEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );
        window.addEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );

      },

      move: ( event ) => {

        this.onDragMove( this.getPosition( event ) );

      },

      end: ( event ) => {

        this.onDragEnd( this.getPosition( event ) );
        window.removeEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );
        window.removeEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );

      },

    };

    this.onDragStart = () => {};
    this.onDragMove = () => {};
    this.onDragEnd = () => {};

    this.element = element;
    this.element.addEventListener( 'touchstart', this.drag.start, false );
    this.element.addEventListener( 'mousedown', this.drag.start, false );

  }

  getPosition( event ) {

    const dragEvent = event.touches ? ( event.touches[ 0 ] || event.changedTouches[ 0 ] ) : event;
    return new THREE.Vector2( dragEvent.pageX, dragEvent.pageY );

  }

  convertPosition( position ) {

    position.x = ( position.x / this.element.offsetWidth ) * 2 - 1;
    position.y = - ( ( position.y / this.element.offsetHeight ) * 2 - 1 );
    return position;

  }

}

Init();
Controls();

</script></body></html>
