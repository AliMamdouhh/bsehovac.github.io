<!DOCTYPE html><html><head><style type="text/css">
  body, html, div, canvas { margin: 0; padding: 0; width: 100vw; height: 100vh; overflow: hidden; display: block; }
</style></head><body>
<script type="text/javascript" src="assets/js/three.js"></script>
<script type="text/javascript">

function Controls() {

  const draggable = new Draggable( container );
  const drag = {};

  draggable.onDragStart = position => {

    const cubeIntersect = getIntersect( position.current, cube );

    if ( cubeIntersect !== false ) {

      drag.normal = cubeIntersect.face.normal;
      drag.type = 'layer';

      attach( helper, scene, cube )

      helper.rotation.set( 0, 0, 0 );
      helper.position.set( 0, 0, 0 );
      helper.lookAt( drag.normal );
      helper.translateZ( 0.5 );
      helper.updateMatrixWorld();

      detach( helper, cube, scene );

    } else {

      drag.normal = new THREE.Vector3( 0, 0, 1 );
      drag.type = 'cube';

      helper.position.set( 0, 0, 0 );
      helper.rotation.set( 0, Math.PI / 4, 0 );
      helper.updateMatrixWorld();

    }

    const helperIntersect = getIntersect( position.current, helper ).point;

    drag.current = helper.worldToLocal( helperIntersect );
    drag.total = new THREE.Vector3();
    drag.axis = null;

  };

  

  draggable.onDragMove = position => {

    const helperIntersect = getIntersect( position.current, helper );
    if ( helperIntersect === false ) return;

    const point = helper.worldToLocal( helperIntersect.point.clone() );

    const delta = point.clone().sub( drag.current ).setZ( 0 );
    drag.total.add( delta );
    drag.current = point;

    if ( drag.axis === null && drag.total.length() > 0.1 ) {

      drag.direction = getLargesAxis( drag.total );

      if ( drag.type === 'layer' ) {

        const direction = new THREE.Vector3();
        direction[ drag.direction ] = 1;

        const worldDirection = helper.localToWorld( direction ).sub( helper.position );
        const objectDirection = object.worldToLocal( worldDirection ).round();

        drag.axis = objectDirection.cross( drag.normal ).negate();

      } else {

        const axis = ( drag.direction != 'x' )
          ? ( ( drag.direction == 'y' && position.current.x > container.offsetWidth / 2 ) ? 'z' : 'x' )
          : 'y';

        drag.axis = new THREE.Vector3();
        drag.axis[ axis ] = 1 * ( ( axis == 'x' ) ? - 1 : 1 );

      }

    } else if ( drag.axis !== null && drag.axis !== 'stop' ) {

      if ( drag.type == 'layer' ) { 

        object.rotateOnAxis( drag.axis, delta[ drag.direction ] );

      } else {

        object.rotateOnWorldAxis( drag.axis, delta[ drag.direction ] );

      }

    }

  };

  draggable.onDragEnd = position => {


  };

  function getIntersect( position, object ) {

    raycaster.setFromCamera( draggable.convertPosition( position.clone() ), camera );
    const intersect = raycaster.intersectObject( object );
    return ( intersect.length > 0 ) ? intersect[ 0 ] : false;

  }

  function getLargesAxis( vector ) {

    return Object.keys( vector ).reduce( ( a, b ) => Math.abs( vector[ a ] ) > Math.abs( vector[ b ] ) ? a : b );

  }

  function detach( child, parent, scene ) {

    child.applyMatrix( parent.matrixWorld );
    parent.remove( child );
    scene.add( child );

  }

  function attach( child, scene, parent ) {

    child.applyMatrix( new THREE.Matrix4().getInverse( parent.matrixWorld ) );
    scene.remove( child );
    parent.add( child );

  }

}

function Init() {

  const scene = new THREE.Scene();

  const renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );

  const container = document.createElement('div');
  container.appendChild( renderer.domElement );
  document.body.appendChild( container );

  const camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 1, 1000 );
  camera.position.set( 3, 3, 3 );
  camera.lookAt( scene.position );

  const light = new THREE.DirectionalLight( 0xffffff, 5 );
  light.position.set( 0.3, 1,  0.6 );

  const raycaster = new THREE.Raycaster();

  const object = new THREE.Object3D();

  const cube = new THREE.Mesh(
    new THREE.BoxGeometry( 1, 1, 1 ),
    new THREE.MeshStandardMaterial( { transparent: true, opacity: 0.5, color: 0x333333 } )
  );

  const helper = new THREE.Mesh(
    new THREE.PlaneGeometry( 200, 200 ),
    new THREE.MeshBasicMaterial( { transparent: true, opacity: 0.1, color: 0x0033ff } )
  );

  object.add( cube );
  scene.add( helper, camera, object, light );

  // cube.add( new THREE.AxesHelper( 0.5 ) );
  // helper.add( new THREE.AxesHelper( 1 ) );
  // scene.add( new THREE.AxesHelper( 1 ) );

  const animate = () => {

    renderer.render( scene, camera );
    requestAnimationFrame( animate );

  }

  animate();

  window.scene = scene;
  window.cube = cube;
  window.helper = helper;
  window.object = object;
  window.container = container;
  window.raycaster = raycaster;
  window.camera = camera;

}

class Draggable {

  constructor( element ) {

    window.addEventListener( 'touchmove', function () {} );
    document.addEventListener( 'touchmove', function( event ){ event.preventDefault(); }, { passive: false } );

    this.position = {
      start: new THREE.Vector2(),
      current: new THREE.Vector2(),
      delta: new THREE.Vector2(),
      drag: new THREE.Vector2(),
      old: new THREE.Vector2(),
      momentum: new THREE.Vector2(),
    };

    this.momentum = [];
    this.element = null;
    this.touch = null;

    this.drag = {

      start: ( event ) => {

        if ( event.type == 'mousedown' && event.which != 1 ) return;
        if ( event.type == 'touchstart' && event.touches.length > 1 ) return;

        this.getPositionCurrent( event );
        this.position.start = this.position.current.clone();
        this.position.delta.set( 0, 0 );
        this.position.drag.set( 0, 0 );
        this.position.momentum.set( 0, 0 );
        this.touch = ( event.type == 'touchstart' );

        this.onDragStart( this.position );

        window.addEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );
        window.addEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );

      },

      move: ( event ) => {

        this.position.old = this.position.current.clone();
        this.getPositionCurrent( event );
        this.position.delta = this.position.current.clone().sub( this.position.old );
        this.position.drag = this.position.current.clone().sub( this.position.start );
        this.addMomentumPoint( this.position.delta );

        this.onDragMove( this.position );

      },

      end: ( event ) => {

        this.getPositionCurrent( event );
        this.getMomentum();

        this.onDragEnd( this.position );

        window.removeEventListener( ( this.touch ) ? 'touchmove' : 'mousemove', this.drag.move, false );
        window.removeEventListener( ( this.touch ) ? 'touchend' : 'mouseup', this.drag.end, false );

      },

    };

    this.onDragStart = () => {};
    this.onDragMove = () => {};
    this.onDragEnd = () => {};

    this.init( element );

    return this;

  }

  init( element ) {

    this.element = element;
    this.element.addEventListener( 'touchstart', this.drag.start, false );
    this.element.addEventListener( 'mousedown', this.drag.start, false );

    return this;

  }

  dispose() {

    this.element.removeEventListener( 'touchstart', this.drag.start, false );
    this.element.removeEventListener( 'mousedown', this.drag.start, false );

    return this;

  }

  getPositionCurrent( event ) {

    const dragEvent = event.touches
      ? ( event.touches[ 0 ] || event.changedTouches[ 0 ] )
      : event;

    this.position.current.set( dragEvent.pageX, dragEvent.pageY );

  }

  convertPosition( position ) {

    position.x = ( position.x / this.element.offsetWidth ) * 2 - 1;
    position.y = - ( ( position.y / this.element.offsetHeight ) * 2 - 1 );

    return position;

  }

  addMomentumPoint( delta ) {

    const time = Date.now();

    while ( this.momentum.length > 0 ) {

      if ( time - this.momentum[0].time <= 200 ) break;
      this.momentum.shift();

    }

    if ( delta !== false ) this.momentum.push( { delta, time } );

  }

  getMomentum() {

    const points = this.momentum.length;
    const momentum = new THREE.Vector2();

    this.addMomentumPoint( false );

    this.momentum.forEach( ( point, index ) => {

      momentum.add( point.delta.multiplyScalar( index / points ) )

    } );

    return momentum;

  }

}

Init();
Controls();

</script></body></html>
